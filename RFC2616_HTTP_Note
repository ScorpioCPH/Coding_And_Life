This is a learning note about RFC2616, which difined the HTTP/1.1

1.Some Terminology 术语:

  Connection: 连接，传输层的虚拟回路，由想要进行通信的两个程序创建。
  Message: 消息，HTTP的基本通信单元，由结构化的字节序列组成，它满足特定的语法，并且通过连接进行传输。
  Request: 请求，或称请求消息。
  Response: 响应，或称响应消息。
  Resource: 资源，通过URI定义的，网络数据对象或者服务，它可以有多种的表现形式（多语言，数据格式，大小，分辨率等）。
  Entity: 实体，作为被传递的信息，是请求或是响应的有效载荷。
          它由两部分组成：存在于实体标题区的“元信息”,以及存在于实体主体区的内容。
  Representation: 表现形式，一个响应包含的实体是由内容协商决定的，有可能存在一个特定的响应状态对应多个表现形式。
  Content Negotiation: 内容协商，一种根据请求来选择表现的机制。
                       每一个响应中的实体表现都可以被协商，包括错误响应。
  Variant: 变体，在任何时刻，一个资源都有可能存在一个或是多个连接到它上面的表现。
           每一个这种表现，都是一个“变体”，使用变体这个概念，并不一定意味着，资源就是内容协商的主题。
  Client: 客户端，一个程序，通过建立连接来完成发送请求的目的。
  User Agent: 用户代理，发起请求的客户端。通常是浏览器，编辑器，网络爬虫，或是终端用户工具。
  Server: 服务器，一个应用程序，可以接受客户端的连接请求，并通过向客户端发送响应来处理请求。
          任何程序，都有可能成为客户端或者服务器。
          我们用这些概念（客户端、服务器）来表明特定连接中，应用程序所扮演的角色，而不是应用程序通常的功能。
          同样的，根据不同请求的性质，任何服务器都可以通过切换它们的行为，来作为源服务器，代理服务器，网关，或是管道等角色。
  Origin Server: 源服务器，存储或创建资源的服务器。
  Proxy: 代理，一个中间程序，既充当服务器，也作为客户端，为了代表其他客户端提出请求。
         请求被内部处理，或者被传递（有可能被翻译）给其他服务器。
         一个代理必须完成服务器和客户端的功能需求。
         透明代理“transparent proxy”需要代理认证和代理识别，它不会修改请求或响应。
         非透明代理“nontransparent proxy”需修改请求或响应，以便为用户代理“user agent”提供附加服务，
         例如组注释服务，媒体类型转换，协议简化，或者匿名过滤等。
         除非被显式地声明，否则，HTTP代理既是透明代理也是非透明代理。
  Gateway: 网关，其实是一个中间服务器，介于其它服务器和客户端之间。
           与代理不同，网关接收请求，仿佛它就是请求资源的源服务器。
           发出请求的客户端可能觉察不到它正在同网关通信。
  Tunnel: 隧道，隧道也是一个中间程序，它在两个连接之间充当盲目中继“blind relay”。
          一旦隧道处于活动状态，它不能被认为是这次HTTP通信的参与者，虽然HTTP请求可能已经把它初始化了。
          当中继连接的两端都关闭的时候，隧道就不再存在。
  Cache: 缓存，缓存是响应消息的本地存储，也是一个子系统，用来控制消息的保存，检索和删除。
         缓存保存了可缓存的响应“cacheable response”，来减少将来相同请求的响应时间和网络带宽消耗。
         任何客户端和服务器都可以有缓存，但缓存不能被充当管道的服务器使用。
  Cacheable: 可缓存的，如果一个响应消息允许缓存程序保存它的副本，用来响应接下来的响应序列，那么可以说这个响应消息是可缓存的。
             如何确定响应消息的可缓存能力在第13章有描述。
             尽管某个资源是可缓存的，但针对特殊的请求，仍然有可能约束缓存来保存这个副本。
  First-Hand: 第一手，如果一个响应消息直接从源服务器获得（可能经过若干代理服务器），没有不必要的延时，
              那么可以说这个响应消息是第一手的。
              如果一个响应消息的有效性直接被源服务器确认，那么也可以说它是第一手的。
  Explicit Expiration Time: 显示过期时间，当这一时间到达后，如果缓存没有对缓存的副本进行重新验证，
                            那么不允许使用此副本区响应后续的请求。
  Heuristic Expiration Time: 启发式过期时间，当没有可用的显示过期时间时，由缓存指定的过期时间。
  Age: 年龄，一个响应消息的年龄，是指从它被源服务器发出，或是被源服务器验证成功地时刻，到现在的时间间隔。
  Freshness Lifetime: 保鲜期，一个响应消息的产生到过期之间的时间间隔。
  Fresh: 新鲜的，如果一个响应消息的年龄没有超过它的保鲜期，那么可以说这个响应消息是新鲜的。
  Stale: 陈旧的，如果一个响应消息的年龄超过了它的保鲜期，那么可以说这个响应消息是陈旧的。
  Semantically Transparent: 语义透明，缓存“cache”可能会以一种语意透明"semantically transparent"的方式工作。
                            这时，对于一个特定的响应，使用缓存既不会对请求客户端产生影响，也不会对源服务器产生影响，
                            缓存的使用只是为了提高性能。
                            当缓存“cache”具有语意透明时，客户端从缓存接收的响应跟直接从源服务器接收的响应完全一致
                            （除了使用hop-by-hop头域）。
  Validator: 验证器，验证期是一个协议元素（例如实体标签"entity tag"，或是最终修改时间），
             用来识别一个缓存里的副本，是否是一个源服务器的实体的等价拷贝。
  Upstream/Downstream: 上游/下游，描述了一个消息的流动：所有的消息都是从上游流向下游。
  Inbound/Outbound: 入站/出站，指明了消息的请求/响应路径，
                    “入站”意味着“流向源服务器”，“出站”意味着“流向客户端user agent”。

2.Overall Operation 概述：

  HTTP是一个响应/请求的协议。
  客户端给服务器发送请求消息，格式是这样的，一个请求方法“request method”，加上URI，
  加上协议版本号，然后紧接着一个包含请求修饰符“modifiers”，客户端信息，和可能的消息主体，类似MIME（MIME-like）消息。
  服务器对请求端发送响应消息，格式是这样的，一个状态行“status line”，
  其后跟随一个包含服务器信息、实体元信息和可能的实体主体内容，类似MIME（MIME-like）消息。
  其中状态行“status line”包含消息的协议版本号和一个成功或错误码。
  
  大部分的HTTP通信是由用户代理“user agent”发起的，由应用于一个源服务器资源的请求消息构成。
  最简单的情形，这可以通过用户代理（UA）和源服务器（O）之间的单一连接（v）来实现。
      
      请求链（request chain）------------------------------------------------>
      用户代理（UA）----------------单一连接（v）--------------源服务器（O）
      <----------------------------------------------------------响应链（response chain）
      
  有可能在请求/响应链中出现一个或多个中间者“intermediares”，这是比较复杂的情形。
  常见的中间者“intermediares”有三种：代理（proxy），网关（gateway）和隧道（tunnel）。
  代理（proxy）是一种转发代理“a forwarding agent”，它接收绝对URI“Absoulute ERI”请求，重写全部或部分消息，
  然后把格式化后的请求转发到URI指定的服务器上。
  网关（gateway）是一种接收代理“receiving agent”，它充当某些服务器之上的层，
  必要时它会把请求翻译成为下层服务器的协议。
  隧道（tunnel）不改变消息，而充当两个连接之间的中继点；
  它用于通信需要穿过中间者（如防火墙），甚至当中间者不能理解消息内容的时候。
  
      请求链（request chain）---------------------------------------->
      用户代理（UA）-----v-----A-----v-----B-----v-----C------v-----源服务器（O）
      <----------------------------------------响应链（response chain）
  
  上图显示了用户代理“user agent”和源服务器之间的三个中间者（A，B和C）。
  整条链的请求消息或响应消息，将会通过四个被隔离开的连接（UA---A，A---B，B---C，C---O）。
  这个不同点很重要，因为某些HTTP通信选项有可能只能采用最近的非隧道邻接点的连接，有可能只采用链的端点“end-point”，
  或者也有可能采用于链上所有连接。
  尽管上面的图表是线性的，但每个参与者可能忙于多个并发的通信。
  例如，B可以接收来自不是A的许多客户端的请求，并且/或者可以把请求转发到不是C的服务器，与此同时，C正在处理A的请求。
  
  通信中任何非隧道成员都可能会采用一个内部缓存“internal cache”来处理请求。
  内部缓存的效果是，如果通信链路上的参与者，已经缓存了请求对应的响应，请求/响应链就会大大缩短。
  下图阐明了一个最终请求响应链，假定B拥有一个来自于O（通过C）的响应消息的缓存副本，并且此请求的响应并未被UA或A缓存。

      请求链（request chain）---------->
      UA-----v----------A-----v-----B-----C----O
      <---------响应链 （response chain）
  
  并不是所有的响应都能有效地缓存，一些请求可能含有修饰符“modifiers”，这些修饰符对缓存动作有特殊的要求。
  HTTP对缓存行为和可缓存响应“cacheable responses”的定义在第13章定义。
  
  实际上，目前万维网上有多种被实践和部署的缓存和代理的体系结构和配置。
  这些系统包括节省带宽的缓存代理“proxy cache”层次“hierarchies”系统，
  可以广播“broadcast”或多播“multicast）”缓存数据的系统，
  通过CD-ROM发布缓存数据子集的机构，等等。
  HTTP系统会被应用于宽带连接的企业局域网中的协作，并且可以被用于PDAs进行低耗无线断续连接访问。
  HTTP1.1的宗旨是为了支持各种各样的已经部署的配置，同时引进一种协议结构，让它满足可以建立高可靠性的web应用程序，
  即使不能达到这种要求，也至少可以可靠的定位故障。

  HTTP通信通常发生在TCP/IP连接上。默认端口是TCP 80，不过其它端口也可以使用。
  但并不排除HTTP协议会在其它协议之上被实现。
  HTTP仅仅期望的是一个可靠的传输（译注：HTTP一般建立在传输层协议之上）；
  所以任何提供这种保证的协议都可以被使用；
  协议传输数据单元“transport data unit”与HTTP/1.1请求和响应的消息结构之间的映象已经超出了本规范的范围。
  
  大部分HTTP/1.0 的实现都是对每个请求/响应交换，产生一个新的连接。
  而HTTP/1.1中，一个连接可以用于一个或更多请求/响应交换，虽然连接可能会因为各种原因中断（见第8.1节）。
